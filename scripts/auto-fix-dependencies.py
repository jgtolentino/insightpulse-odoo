#!/usr/bin/env python3
"""
Automated Dependency Fixer for Odoo Deployments
Validates and auto-patches common dependency issues
"""

import os
import sys
import subprocess
import json
from pathlib import Path
from typing import Dict, List, Tuple

# Odoo 19.0 Requirements
REQUIRED_PYTHON_VERSION = "3.11"
REQUIRED_POSTGRES_VERSION = "15"
REQUIRED_SYSTEM_PACKAGES = [
    "libxml2-dev",
    "libxslt1-dev",
    "libldap2-dev",
    "libsasl2-dev",
    "libssl-dev",
    "libpq-dev",
]

# Common missing Python packages for OCA modules
COMMON_MISSING_PACKAGES = {
    "account-financial-reporting": ["openpyxl", "xlsxwriter"],
    "server-tools": ["python-stdnum", "PyPDF2"],
    "web": ["werkzeug>=2.0"],
    "reporting-engine": ["jinja2", "babel"],
}


def check_python_version() -> Tuple[bool, str]:
    """Validate Python version matches Odoo requirements"""
    import sys
    version = f"{sys.version_info.major}.{sys.version_info.minor}"

    if version != REQUIRED_PYTHON_VERSION:
        return False, f"Python {REQUIRED_PYTHON_VERSION} required, found {version}"
    return True, f"Python {version} ‚úì"


def check_postgres_version() -> Tuple[bool, str]:
    """Check PostgreSQL version if accessible"""
    try:
        result = subprocess.run(
            ["psql", "--version"],
            capture_output=True,
            text=True,
            timeout=5
        )
        version_str = result.stdout.strip()

        # Extract major version
        version_parts = version_str.split()
        for part in version_parts:
            if part.replace(".", "").isdigit():
                major_version = int(part.split(".")[0])
                if major_version >= int(REQUIRED_POSTGRES_VERSION):
                    return True, f"PostgreSQL {part} ‚úì"
                else:
                    return False, f"PostgreSQL {REQUIRED_POSTGRES_VERSION}+ required, found {part}"

        return True, "PostgreSQL version check skipped (psql not available locally)"
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return True, "PostgreSQL version check skipped (not accessible)"


def scan_missing_system_packages() -> List[str]:
    """Identify missing system packages"""
    missing = []

    for pkg in REQUIRED_SYSTEM_PACKAGES:
        # Check if package is installed (Debian/Ubuntu)
        result = subprocess.run(
            ["dpkg", "-l", pkg],
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            missing.append(pkg)

    return missing


def scan_addon_dependencies(addons_path: Path) -> Dict[str, List[str]]:
    """Scan all addons and extract Python dependencies"""
    dependencies = {}

    for addon_dir in addons_path.rglob("__manifest__.py"):
        addon_name = addon_dir.parent.name
        manifest_path = addon_dir

        try:
            with open(manifest_path, 'r') as f:
                manifest = eval(f.read())

            # Check for external_dependencies
            if 'external_dependencies' in manifest:
                python_deps = manifest['external_dependencies'].get('python', [])
                if python_deps:
                    dependencies[addon_name] = python_deps
        except Exception as e:
            print(f"‚ö†Ô∏è  Error reading {addon_name}: {e}")

    return dependencies


def generate_requirements_txt(dependencies: Dict[str, List[str]], output_path: Path):
    """Generate comprehensive requirements.txt"""
    all_packages = set()

    # Add dependencies from manifests
    for addon, deps in dependencies.items():
        all_packages.update(deps)

    # Add common OCA dependencies
    for oca_module, deps in COMMON_MISSING_PACKAGES.items():
        all_packages.update(deps)

    # Write requirements.txt
    with open(output_path, 'w') as f:
        f.write("# Auto-generated Odoo 19.0 requirements\n")
        f.write("# Generated by auto-fix-dependencies.py\n\n")

        for pkg in sorted(all_packages):
            f.write(f"{pkg}\n")

    print(f"‚úì Generated {output_path} with {len(all_packages)} packages")


def auto_patch_manifest_errors(addons_path: Path) -> int:
    """Auto-fix common manifest errors"""
    fixed_count = 0

    for manifest_path in addons_path.rglob("__manifest__.py"):
        addon_name = manifest_path.parent.name

        try:
            with open(manifest_path, 'r') as f:
                content = f.read()
                manifest = eval(content)

            changes_made = False

            # Fix 1: Add missing 'license' field
            if 'license' not in manifest:
                manifest['license'] = 'AGPL-3'
                changes_made = True
                print(f"  ‚Üí Added missing license to {addon_name}")

            # Fix 2: Ensure 'depends' is a list
            if 'depends' in manifest and not isinstance(manifest['depends'], list):
                manifest['depends'] = [manifest['depends']]
                changes_made = True
                print(f"  ‚Üí Fixed depends format in {addon_name}")

            # Fix 3: Ensure 'data' is a list
            if 'data' in manifest and not isinstance(manifest['data'], list):
                manifest['data'] = [manifest['data']]
                changes_made = True
                print(f"  ‚Üí Fixed data format in {addon_name}")

            # Fix 4: Add 'installable' if missing
            if 'installable' not in manifest:
                manifest['installable'] = True
                changes_made = True
                print(f"  ‚Üí Added installable flag to {addon_name}")

            if changes_made:
                # Write back to file
                with open(manifest_path, 'w') as f:
                    f.write("{\n")
                    for key, value in manifest.items():
                        f.write(f"    '{key}': {repr(value)},\n")
                    f.write("}\n")

                fixed_count += 1

        except Exception as e:
            print(f"‚ö†Ô∏è  Error processing {addon_name}: {e}")

    return fixed_count


def check_circular_dependencies(addons_path: Path) -> List[str]:
    """Detect circular dependency loops"""
    dependencies = {}

    # Build dependency graph
    for manifest_path in addons_path.rglob("__manifest__.py"):
        addon_name = manifest_path.parent.name

        try:
            with open(manifest_path, 'r') as f:
                manifest = eval(f.read())

            deps = manifest.get('depends', [])
            dependencies[addon_name] = deps
        except:
            continue

    # Detect cycles using DFS
    def has_cycle(node, visited, rec_stack):
        visited.add(node)
        rec_stack.add(node)

        for neighbor in dependencies.get(node, []):
            if neighbor not in visited:
                if has_cycle(neighbor, visited, rec_stack):
                    return True
            elif neighbor in rec_stack:
                return True

        rec_stack.remove(node)
        return False

    cycles = []
    visited = set()

    for addon in dependencies:
        if addon not in visited:
            rec_stack = set()
            if has_cycle(addon, visited, rec_stack):
                cycles.append(addon)

    return cycles


def main():
    """Main validation and auto-fix routine"""
    print("üîß Odoo Deployment Auto-Fix Utility")
    print("=" * 50)
    print()

    # Check Python version
    python_ok, python_msg = check_python_version()
    print(f"Python Version: {python_msg}")
    if not python_ok:
        print("‚ùå CRITICAL: Incompatible Python version")
        sys.exit(1)

    # Check PostgreSQL version
    postgres_ok, postgres_msg = check_postgres_version()
    print(f"PostgreSQL Version: {postgres_msg}")

    # Check system packages
    print("\nSystem Packages:")
    missing_packages = scan_missing_system_packages()

    if missing_packages:
        print(f"‚ö†Ô∏è  Missing packages: {', '.join(missing_packages)}")
        print(f"   Install with: sudo apt-get install {' '.join(missing_packages)}")
    else:
        print("‚úì All required system packages installed")

    # Scan addon dependencies
    addons_path = Path("addons")

    if not addons_path.exists():
        print("\n‚ö†Ô∏è  No 'addons' directory found")
        return

    print(f"\nScanning addons in {addons_path}...")
    dependencies = scan_addon_dependencies(addons_path)

    if dependencies:
        print(f"Found {len(dependencies)} addons with Python dependencies:")
        for addon, deps in dependencies.items():
            print(f"  ‚Ä¢ {addon}: {', '.join(deps)}")

        # Generate requirements.txt
        generate_requirements_txt(dependencies, Path("requirements-auto.txt"))

    # Auto-fix manifest errors
    print("\nAuto-fixing manifest errors...")
    fixed_count = auto_patch_manifest_errors(addons_path)
    print(f"‚úì Fixed {fixed_count} manifest files")

    # Check for circular dependencies
    print("\nChecking for circular dependencies...")
    cycles = check_circular_dependencies(addons_path)

    if cycles:
        print(f"‚ö†Ô∏è  Circular dependencies detected in: {', '.join(cycles)}")
        print("   Manual review required")
    else:
        print("‚úì No circular dependencies detected")

    print("\n" + "=" * 50)
    print("Auto-fix complete!")

    if not python_ok or missing_packages:
        print("\n‚ö†Ô∏è  Some issues require manual intervention")
        sys.exit(1)
    else:
        print("\n‚úì All checks passed!")
        sys.exit(0)


if __name__ == '__main__':
    main()
