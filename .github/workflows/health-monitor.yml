name: Health Monitor (WAF-aware)

on:
  schedule:
    # Run every 30 minutes (reduced from 5 minutes to prevent issue spam)
    - cron: '*/30 * * * *'

  workflow_dispatch:
    inputs:
      check_origins:
        description: 'Check origin health (bypass WAF)'
        required: false
        type: boolean
        default: true

env:
  # Droplet origin IPs
  ERP_ORIGIN_IP: "165.227.10.178"
  OCR_ORIGIN_IP: "188.166.237.231"

jobs:
  public-health:
    name: Public Endpoints (via WAF)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check ERP (public)
        id: erp_public
        run: |
          echo "Checking https://erp.insightpulseai.net/web/health"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            "https://erp.insightpulseai.net/web/health" || echo "000")

          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT

          # Accept 200-399 and 403 (WAF)
          if [[ "$HTTP_CODE" =~ ^(200|201|204|301|302|307|308|403)$ ]]; then
            echo "âœ“ ERP public endpoint: HTTP $HTTP_CODE (healthy)"
            exit 0
          else
            echo "âœ— ERP public endpoint: HTTP $HTTP_CODE (unhealthy)"
            exit 1
          fi

      - name: Check MCP (public)
        id: mcp_public
        run: |
          echo "Checking https://mcp.insightpulseai.net/health"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            "https://mcp.insightpulseai.net/health" || echo "000")

          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [[ "$HTTP_CODE" =~ ^(200|201|204|301|302|307|308|403)$ ]]; then
            echo "âœ“ MCP public endpoint: HTTP $HTTP_CODE (healthy)"
            exit 0
          else
            echo "âœ— MCP public endpoint: HTTP $HTTP_CODE (unhealthy)"
            exit 1
          fi

      - name: Check Superset (public)
        id: superset_public
        run: |
          echo "Checking https://superset.insightpulseai.net"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            "https://superset.insightpulseai.net" || echo "000")

          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [[ "$HTTP_CODE" =~ ^(200|201|204|301|302|307|308|403)$ ]]; then
            echo "âœ“ Superset public endpoint: HTTP $HTTP_CODE (healthy)"
            exit 0
          else
            echo "âœ— Superset public endpoint: HTTP $HTTP_CODE (unhealthy)"
            exit 1
          fi

      - name: Check OCR (public)
        id: ocr_public
        run: |
          echo "Checking https://ocr.insightpulseai.net/health"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            "https://ocr.insightpulseai.net/health" || echo "000")

          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [[ "$HTTP_CODE" =~ ^(200|201|204|301|302|307|308|403)$ ]]; then
            echo "âœ“ OCR public endpoint: HTTP $HTTP_CODE (healthy)"
            exit 0
          else
            echo "âœ— OCR public endpoint: HTTP $HTTP_CODE (unhealthy)"
            exit 1
          fi

      - name: Check LLM (public)
        id: llm_public
        continue-on-error: true
        run: |
          echo "Checking https://llm.insightpulseai.net/health"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            "https://llm.insightpulseai.net/health" || echo "000")

          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [[ "$HTTP_CODE" =~ ^(200|201|204|301|302|307|308|403)$ ]]; then
            echo "âœ“ LLM public endpoint: HTTP $HTTP_CODE (healthy)"
            exit 0
          else
            echo "âš  LLM public endpoint: HTTP $HTTP_CODE (may not be deployed yet)"
            exit 0
          fi

  origin-health:
    name: Origin Health (bypass WAF)
    runs-on: ubuntu-latest
    if: github.event.inputs.check_origins != 'false'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make scripts executable
        run: chmod +x scripts/wait_healthy.sh

      - name: Check ERP Origin
        id: erp_origin
        run: |
          echo "Checking ERP origin at ${{ env.ERP_ORIGIN_IP }}"

          # Direct origin check (bypass Cloudflare)
          HTTP_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            -H "Host: erp.insightpulseai.net" \
            "https://${{ env.ERP_ORIGIN_IP }}/web/health" || echo "000")

          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT

          # Origin should return 200-3xx (not 403, which indicates WAF)
          if [[ "$HTTP_CODE" =~ ^(200|201|204|301|302|307|308)$ ]]; then
            echo "âœ“ ERP origin: HTTP $HTTP_CODE (healthy)"
            exit 0
          else
            echo "âœ— ERP origin: HTTP $HTTP_CODE (unhealthy - origin not responding correctly)"
            exit 1
          fi

      - name: Check OCR Origin
        id: ocr_origin
        run: |
          echo "Checking OCR origin at ${{ env.OCR_ORIGIN_IP }}"

          HTTP_CODE=$(curl -k -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            -H "Host: ocr.insightpulseai.net" \
            "https://${{ env.OCR_ORIGIN_IP }}/health" || echo "000")

          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [[ "$HTTP_CODE" =~ ^(200|201|204|301|302|307|308)$ ]]; then
            echo "âœ“ OCR origin: HTTP $HTTP_CODE (healthy)"
            exit 0
          else
            echo "âœ— OCR origin: HTTP $HTTP_CODE (unhealthy)"
            exit 1
          fi

  notify:
    name: Notify on Failure
    needs: [public-health]
    runs-on: ubuntu-latest
    if: needs.public-health.result == 'failure'

    steps:
      - name: Send Slack Notification
        if: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        run: |
          curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "ðŸš¨ Health Check Failed",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "ðŸš¨ Health Check Failed"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Timestamp:*\n'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Repository:*\n${{ github.repository }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Public Health:*\n${{ needs.public-health.result }}"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Workflow Run"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }' || echo "Failed to send Slack notification"

      - name: Send Discord Notification
        if: ${{ secrets.DISCORD_WEBHOOK_URL != '' }}
        run: |
          curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "embeds": [{
                "title": "ðŸš¨ Health Check Failed",
                "color": 15548997,
                "fields": [
                  {
                    "name": "Timestamp",
                    "value": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'",
                    "inline": true
                  },
                  {
                    "name": "Repository",
                    "value": "${{ github.repository }}",
                    "inline": true
                  },
                  {
                    "name": "Public Health",
                    "value": "${{ needs.public-health.result }}",
                    "inline": true
                  }
                ],
                "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              }]
            }' || echo "Failed to send Discord notification"

      - name: Send PagerDuty Alert
        if: ${{ secrets.PAGERDUTY_INTEGRATION_KEY != '' }}
        run: |
          curl -X POST "https://events.pagerduty.com/v2/enqueue" \
            -H "Content-Type: application/json" \
            -d '{
              "routing_key": "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}",
              "event_action": "trigger",
              "dedup_key": "health-check-failure",
              "payload": {
                "summary": "Health Check Failed - InsightPulse Infrastructure",
                "source": "${{ github.repository }}",
                "severity": "error",
                "timestamp": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'",
                "custom_details": {
                  "public_health": "${{ needs.public-health.result }}",
                  "workflow_run": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                }
              }
            }' || echo "Failed to send PagerDuty alert"

      - name: Log notification status
        run: |
          echo "::warning::Health check failed for one or more services"
          echo "Public health status: ${{ needs.public-health.result }}"
          echo "Real-time notifications sent (if configured)"

      - name: Create or Update GitHub Issue
        uses: actions/github-script@v7
        with:
          script: |
            // Check if there's already an open health check issue
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'health-check',
              per_page: 100
            });

            // If there's already an open issue, just update it with a comment
            if (existingIssues.data.length > 0) {
              const latestIssue = existingIssues.data[0];

              // Fetch up to 100 comments and look at the newest one
              const commentsResponse = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: latestIssue.number,
                per_page: 100,
              });

              const comments = commentsResponse.data;
              const latestComment = comments[comments.length - 1]; // newest

              const now = new Date();
              let shouldComment = true;

              if (latestComment) {
                const lastCommentTime = new Date(latestComment.created_at);
                const diffMs = now - lastCommentTime;
                const diffHours = diffMs / (1000 * 60 * 60);

                // 1-hour cooldown
                if (diffHours < 1) {
                  shouldComment = false;
                }
              }

              if (shouldComment) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: latestIssue.number,
                  body: `ðŸ”„ **Health check still failing** - ${now.toISOString()}\n\n**Public Health**: ${{ needs.public-health.result }}`,
                });
                console.log(`Updated existing issue #${latestIssue.number} with new comment`);
              } else {
                console.log(`Skipping comment on issue #${latestIssue.number} - last comment was less than 1 hour ago`);
              }
              return;
            }

            // Check for recently closed issues (within last 24 hours) to prevent re-opening too quickly
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
            const recentlyClosed = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: 'health-check',
              since: oneDayAgo,
              per_page: 10
            });

            if (recentlyClosed.data.length > 0) {
              const latestClosed = recentlyClosed.data[0];
              const closedAt = new Date(latestClosed.closed_at);
              const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);

              if (closedAt > twoHoursAgo) {
                console.log(`Not creating new issue - issue #${latestClosed.number} was closed less than 2 hours ago. Waiting for cooldown period.`);
                return;
              }
            }

            // No existing issue and cooldown period passed, create a new one
            const title = 'ðŸš¨ Health Check Failed - ' + new Date().toISOString();
            const body = `
            ## Health Check Failure Report

            **Timestamp**: ${new Date().toISOString()}

            **Public Health**: ${{ needs.public-health.result }}

            ### Diagnosis
            One or more public-facing services are not responding correctly.

            ### Next Steps
            1. Check service health endpoints directly
            2. Review Cloudflare WAF logs
            3. Check service logs: \`docker logs <container>\`
            4. Verify DNS configuration
            5. Run manual smoke test: \`./scripts/smoke_test_production.sh\`
            6. Check origin health: Run health monitor workflow with origin checks enabled

            **Contact**: jgtolentino_rn@yahoo.com or support@insightpulseai.com

            ---
            *This issue will be automatically closed when health is restored.*
            *Note: This workflow now runs every 30 minutes and includes deduplication logic to prevent spam.*
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['health-check', 'incident', 'priority-high']
            });

  close-resolved-issues:
    name: Close Resolved Health Issues
    needs: [public-health]
    runs-on: ubuntu-latest
    if: needs.public-health.result == 'success'

    steps:
      - name: Send Slack Success Notification
        if: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        run: |
          curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "âœ… Health Restored",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "âœ… Health Restored"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "All services are now healthy. Previous health check issues will be automatically closed."
                  }
                }
              ]
            }' || true

      - name: Send Discord Success Notification
        if: ${{ secrets.DISCORD_WEBHOOK_URL != '' }}
        run: |
          curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "embeds": [{
                "title": "âœ… Health Restored",
                "description": "All services are now healthy.",
                "color": 5763719
              }]
            }' || true

      - name: Resolve PagerDuty Alert
        if: ${{ secrets.PAGERDUTY_INTEGRATION_KEY != '' }}
        run: |
          curl -X POST "https://events.pagerduty.com/v2/enqueue" \
            -H "Content-Type: application/json" \
            -d '{
              "routing_key": "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}",
              "event_action": "resolve",
              "dedup_key": "health-check-failure"
            }' || true

      - name: Close Health Check Issues
        uses: actions/github-script@v7
        with:
          script: |
            // Find all open health check issues
            const openIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'health-check',
              per_page: 100
            });

            // Close them all since health is now restored
            for (const issue of openIssues.data) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed'
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `âœ… **Health restored** - ${new Date().toISOString()}\n\nAll services are now healthy. Auto-closing this issue.`
              });

              console.log(`Closed issue #${issue.number}`);
            }

            console.log(`Closed ${openIssues.data.length} health check issue(s)`);
